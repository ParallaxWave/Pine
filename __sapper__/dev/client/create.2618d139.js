import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, a as stores$1, b as validate_store, c as component_subscribe, f as element, t as text, j as claim_element, k as children, l as claim_text, g as detach_dev, m as attr_dev, o as add_location, p as insert_dev, r as append_dev, w as set_data_dev, e as space, q as query_selector_all, h as claim_space, n as set_style, x as set_input_value, y as listen_dev, u as noop, z as run_all } from './client.5f7e45b8.js';

/* src/routes/create.svelte generated by Svelte v3.31.2 */
const file = "src/routes/create.svelte";

// (43:6) {#if error}
function create_if_block(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*errorStatus*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*errorStatus*/ ctx[1]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "text-red-500 text-sm mb-2");
			add_location(div, file, 43, 8, 1086);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*errorStatus*/ 2) set_data_dev(t, /*errorStatus*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(43:6) {#if error}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let div2;
	let div1;
	let div0;
	let t1;
	let br0;
	let t2;
	let t3;
	let input;
	let br1;
	let t4;
	let button;
	let t5;
	let mounted;
	let dispose;
	let if_block = /*error*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			t0 = space();
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t1 = text("groups");
			br0 = element("br");
			t2 = space();
			if (if_block) if_block.c();
			t3 = space();
			input = element("input");
			br1 = element("br");
			t4 = space();
			button = element("button");
			t5 = text("Create");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1anpopb\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			t1 = claim_text(div0_nodes, "groups");
			div0_nodes.forEach(detach_dev);
			br0 = claim_element(div1_nodes, "BR", {});
			t2 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			t3 = claim_space(div1_nodes);

			input = claim_element(div1_nodes, "INPUT", {
				type: true,
				class: true,
				placeholder: true
			});

			br1 = claim_element(div1_nodes, "BR", {});
			t4 = claim_space(div1_nodes);
			button = claim_element(div1_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t5 = claim_text(button_nodes, "Create");
			button_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Home";
			attr_dev(div0, "class", "material-icons text-4xl text-gray-500 font-bold");
			set_style(div0, "font-size", "18vw");
			add_location(div0, file, 41, 6, 957);
			add_location(br0, file, 41, 104, 1055);
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "mb-4 border-2 border-gray-300 focus:border-blue-400 rounded-md px-4 py-2");
			attr_dev(input, "placeholder", "Group Name");
			add_location(input, file, 45, 6, 1163);
			add_location(br1, file, 45, 154, 1311);
			attr_dev(button, "class", "bg-green-400 px-4 py-2 rounded-sm text-white font-bold focus:outline-none hover:bg-green-500");
			add_location(button, file, 46, 6, 1322);
			attr_dev(div1, "class", "justify-self-center text-center mt-5 w-5/6 p-8");
			add_location(div1, file, 40, 4, 890);
			attr_dev(div2, "class", "grid justify-items-stretch");
			add_location(div2, file, 39, 2, 845);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, t1);
			append_dev(div1, br0);
			append_dev(div1, t2);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t3);
			append_dev(div1, input);
			set_input_value(input, /*groupName*/ ctx[2]);
			append_dev(div1, br1);
			append_dev(div1, t4);
			append_dev(div1, button);
			append_dev(button, t5);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[5]),
					listen_dev(button, "click", /*create*/ ctx[4], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*error*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, t3);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*groupName*/ 4 && input.value !== /*groupName*/ ctx[2]) {
				set_input_value(input, /*groupName*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $session;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Create", slots, []);
	const { session } = stores$1();
	validate_store(session, "session");
	component_subscribe($$self, session, value => $$invalidate(6, $session = value));
	const username = $session.username;
	let error = false;
	let errorStatus = "";
	let groupName;

	async function create() {
		if (groupName) {
			const creator = username;
			const data = { groupName, creator };

			const options = {
				method: "POST",
				headers: { "Content-type": "application/json" },
				body: JSON.stringify(data)
			};

			const req = await fetch("clusters/create.json", options);
			const info = await req.json();

			if (!info.success) {
				$$invalidate(0, error = true);
				$$invalidate(1, errorStatus = "Group Already Exists");
			}
		} else {
			$$invalidate(0, error = true);
			$$invalidate(1, errorStatus = "Please Enter a Group Name");
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Create> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		groupName = this.value;
		$$invalidate(2, groupName);
	}

	$$self.$capture_state = () => ({
		stores: stores$1,
		session,
		username,
		error,
		errorStatus,
		groupName,
		create,
		$session
	});

	$$self.$inject_state = $$props => {
		if ("error" in $$props) $$invalidate(0, error = $$props.error);
		if ("errorStatus" in $$props) $$invalidate(1, errorStatus = $$props.errorStatus);
		if ("groupName" in $$props) $$invalidate(2, groupName = $$props.groupName);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [error, errorStatus, groupName, session, create, input_input_handler];
}

class Create extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Create",
			options,
			id: create_fragment.name
		});
	}
}

export default Create;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLjI2MThkMTM5LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcm91dGVzL2NyZWF0ZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgc3RvcmVzIH0gZnJvbSAnQHNhcHBlci9hcHAnO1xuICBjb25zdCB7IHNlc3Npb24gfSA9IHN0b3JlcygpXG4gIGNvbnN0IHVzZXJuYW1lID0gJHNlc3Npb24udXNlcm5hbWU7XG4gIGxldCBlcnJvciA9IGZhbHNlO1xuICBsZXQgZXJyb3JTdGF0dXMgPSBcIlwiO1xuICBsZXQgZ3JvdXBOYW1lO1xuICBhc3luYyBmdW5jdGlvbiBjcmVhdGUoKXtcbiAgICBpZihncm91cE5hbWUpe1xuICAgICAgY29uc3QgY3JlYXRvciA9IHVzZXJuYW1lO1xuICAgICAgY29uc3QgZGF0YSA9IHtncm91cE5hbWUsIGNyZWF0b3J9O1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxID0gYXdhaXQgZmV0Y2goJ2NsdXN0ZXJzL2NyZWF0ZS5qc29uJywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBpbmZvID0gYXdhaXQgcmVxLmpzb24oKTtcbiAgICAgIGlmKCFpbmZvLnN1Y2Nlc3Mpe1xuICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yU3RhdHVzID0gXCJHcm91cCBBbHJlYWR5IEV4aXN0c1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgZXJyb3JTdGF0dXMgPSBcIlBsZWFzZSBFbnRlciBhIEdyb3VwIE5hbWVcIjtcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5Ib21lPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbiAgPGRpdiBjbGFzcz1cImdyaWQganVzdGlmeS1pdGVtcy1zdHJldGNoXCI+XG4gICAgPGRpdiBjbGFzcz1cImp1c3RpZnktc2VsZi1jZW50ZXIgdGV4dC1jZW50ZXIgbXQtNSB3LTUvNiBwLThcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtYXRlcmlhbC1pY29ucyB0ZXh0LTR4bCB0ZXh0LWdyYXktNTAwIGZvbnQtYm9sZFwiIHN0eWxlPVwiZm9udC1zaXplOiAxOHZ3O1wiPmdyb3VwczwvZGl2Pjxicj5cbiAgICAgIHsjaWYgZXJyb3J9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LXJlZC01MDAgdGV4dC1zbSBtYi0yXCI+e2Vycm9yU3RhdHVzfTwvZGl2PlxuICAgICAgey9pZn1cbiAgICAgIDxpbnB1dCBiaW5kOnZhbHVlPXtncm91cE5hbWV9IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJtYi00IGJvcmRlci0yIGJvcmRlci1ncmF5LTMwMCBmb2N1czpib3JkZXItYmx1ZS00MDAgcm91bmRlZC1tZCBweC00IHB5LTJcIiBwbGFjZWhvbGRlcj1cIkdyb3VwIE5hbWVcIj48YnI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYmctZ3JlZW4tNDAwIHB4LTQgcHktMiByb3VuZGVkLXNtIHRleHQtd2hpdGUgZm9udC1ib2xkIGZvY3VzOm91dGxpbmUtbm9uZSBob3ZlcjpiZy1ncmVlbi01MDBcIiBvbjpjbGljaz17Y3JlYXRlfT5cbiAgICAgICAgQ3JlYXRlXG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiJdLCJuYW1lcyI6WyJzdG9yZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7NEJBMkNnRCxHQUFXOzs7Ozs7NkNBQVgsR0FBVzs7Ozs7Ozs7Ozs7OztrRUFBWCxHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQURoRCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQUdTLEdBQVM7Ozs7Ozs7Ozs0Q0FDMkYsR0FBTTs7Ozs7OztpQkFKeEgsR0FBSzs7Ozs7Ozs7Ozs7OztnRUFHUyxHQUFTO3lDQUFULEdBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBM0N4QixPQUFPLEtBQUtBLFFBQU07OztPQUNwQixRQUFRLEdBQUcsUUFBUSxDQUFDLFFBQVE7S0FDOUIsS0FBSyxHQUFHLEtBQUs7S0FDYixXQUFXLEdBQUcsRUFBRTtLQUNoQixTQUFTOztnQkFDRSxNQUFNO01BQ2hCLFNBQVM7U0FDSixPQUFPLEdBQUcsUUFBUTtTQUNsQixJQUFJLEtBQUksU0FBUyxFQUFFLE9BQU87O1NBQzFCLE9BQU87SUFDWCxNQUFNLEVBQUUsTUFBTTtJQUNkLE9BQU8sSUFDTCxjQUFjLEVBQUUsa0JBQWtCO0lBRXBDLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUk7OztTQUVyQixHQUFHLFNBQVMsS0FBSyxDQUFDLHNCQUFzQixFQUFFLE9BQU87U0FDakQsSUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJOztRQUN2QixJQUFJLENBQUMsT0FBTztvQkFDZCxLQUFLLEdBQUcsSUFBSTtvQkFDWixXQUFXLEdBQUcsc0JBQXNCOzs7bUJBSXRDLEtBQUssR0FBRyxJQUFJO21CQUNaLFdBQVcsR0FBRywyQkFBMkI7Ozs7Ozs7Ozs7O0VBa0J0QixTQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
